from contextlib import contextmanager


class Configurator(dict):
    """
    Poorman's configurator, basically like AttrDict.

    Reference: https://github.com/facebookresearch/Detectron/blob/main/detectron/utils/collections.py
    """
    __auto_create = False

    def __init__(self, *args, **kwargs):
        self._is_frozen = False
        super(Configurator, self).__init__(*args, **kwargs)

    def __getattr__(self, attr):
        if attr not in self:
            if self.__class__.__auto_create:
                self[attr] = Configurator()
            else:
                raise AttributeError(
                    f"'{type(self).__name__}' object has no attribute '{attr}'. "
                    "If you're trying to auto-create attributes, consider using the 'enable_auto_create' context manager in a with-statement."
                )
        return self[attr]


    def __setattr__(self, attr, value):
        if attr == "_Configurator__auto_create":  # Use name mangling for private attributes
            raise AttributeError("'_auto_create' is read-only!")
        self[attr] = value    # Using __setitem__ under the hood


    @contextmanager
    def enable_auto_create(self):
        original_state = self.__class__.__auto_create
        self.__class__.__auto_create = True
        try:
            yield self
        finally:
            self.__class__.__auto_create = original_state


    def to_dict(self):
        result = {}
        for key, value in self.items():
            if isinstance(value, Configurator):
                result[key] = value.to_dict()
            else:
                result[key] = value
        return result


    @classmethod
    def from_dict(cls, data):
        instance = cls()
        for key, value in data.items():
            if isinstance(value, dict):
                instance[key] = cls.from_dict(value)
            else:
                instance[key] = value

        return instance


    def get_value(self, key):
        """
        Retrieve a nested key using dot-separated notation.
        For example, for a key like "a.b.c", it fetches self['a']['b']['c'] if it exists, otherwise returns default.
        """
        keys  = key.split('.')
        value = self
        for k in keys:
            if k in value:
                value = value[k]
            else:
                raise AttributeError(
                    f"'{type(self).__name__}' object has no attribute '{k}'. "
                )

        return value


    def set_value(self, key, value):
        """
        Set a nested key using dot-separated notation.
        For example, for a key like "a.b.c", it sets value to self['a']['b']['c'].
        Creates necessary nested Configurators if they don't exist.
        """
        if hasattr(self, '_is_frozen') and self._is_frozen:
            raise ValueError(f"{self.__class__.__name__} is frozen and cannot be modified!")
        keys = key.split('.')
        current_value = self
        for i, k in enumerate(keys):
            if i == len(keys) - 1:
                current_value[k] = value
            else:
                if k not in current_value or not isinstance(current_value[k], Configurator):
                    if self.__class__.__auto_create:
                        current_value[k] = Configurator()
                    else:
                        raise AttributeError(
                            f"'{type(self).__name__}' object has no attribute '{k}'. "
                            "If you're trying to auto-create attributes, consider using the 'enable_auto_create' context manager in a with-statement."
                        )
                current_value = current_value[k]

    def merge_with_priority(self, other, self_has_priority=True):
        """
        Function generated by ChatGPT GPT-4 model.
        Merge two Configurator instances, giving priority to either self or other.

        :param other: The other Configurator instance to merge with.
        :param self_has_priority: Boolean to decide if `self` has priority over `other`. 
                                If True, `self`'s values overwrite `other`'s values in case of conflict. 
                                Otherwise, it's the other way around.
        :return: A new merged Configurator instance.
        """
        merged = Configurator()

        # First, fill merged with values from the instance that has lower priority.
        lower_priority_instance = self if not self_has_priority else other
        for key, value in lower_priority_instance.items():
            if isinstance(value, Configurator):
                merged[key] = Configurator.from_dict(value.to_dict())
            else:
                merged[key] = value

        # Now, overwrite with values from the instance that has higher priority.
        higher_priority_instance = self if self_has_priority else other
        for key, value in higher_priority_instance.items():
            if key in merged and isinstance(value, Configurator) and isinstance(merged[key], Configurator):
                merged[key] = merged[key].merge_with_priority(value, self_has_priority)
            else:
                if isinstance(value, Configurator):
                    merged[key] = Configurator.from_dict(value.to_dict())
                else:
                    merged[key] = value

        return merged
    
    def freeze(self):
        """Make the configuration and all nested configurations immutable."""
        object.__setattr__(self, "_is_frozen", True)  # Bypass custom __setattr__
        for key, value in self.items():
            if isinstance(value, Configurator):
                value.freeze()

    def unfreeze(self):
        """Make the configuration and all nested configurations mutable again."""
        object.__setattr__(self, "_is_frozen", False)  # Bypass custom __setattr__
        for key, value in self.items():
            if isinstance(value, Configurator):
                value.unfreeze()

    def __setitem__(self, key, value):
        if hasattr(self, '_is_frozen') and self._is_frozen:
            raise ValueError(f"{self.__class__.__name__} is frozen and cannot be modified!")
        super(Configurator, self).__setitem__(key, value)

    def __setattr__(self, key, value):
        if key != "_is_frozen" and hasattr(self, '_is_frozen') and self._is_frozen:
            raise ValueError(f"{self.__class__.__name__} is frozen and cannot be modified!")
        super(Configurator, self).__setattr__(key, value)

    
class Singleton(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if hasattr(cls, '_bypass_singleton') and cls._bypass_singleton:
            return super().__call__(*args, **kwargs)
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class GlobalConfigurator(Configurator, metaclass=Singleton):
    """ Adapted from the draft by ChatGPT GPT-4 model.
    """
    _bypass_singleton = False

    def __init__(self, *args, **kwargs):
        super(GlobalConfigurator, self).__init__(*args, **kwargs)

    def set_value(self, key, value):
        if key != "_is_frozen" and hasattr(self, '_is_frozen') and self._is_frozen:
            raise ValueError(f"{self.__class__.__name__} is frozen and cannot be modified!")
        super(GlobalConfigurator, self).set_value(key, value)

    
    @classmethod
    def from_dict(cls, data):
        if cls._bypass_singleton:
            instance = super(Singleton, cls).__call__()
        else:
            instance = cls()

        for key, value in data.items():
            if isinstance(value, dict):
                cls._bypass_singleton = True
                instance[key] = cls.from_dict(value)
                cls._bypass_singleton = False
            else:
                instance[key] = value

        return instance
